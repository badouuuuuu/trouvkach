{"version":3,"sources":["webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/utils/bignumber/bitNot.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/utils/bignumber/constants.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/utils/bignumber/formatter.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/utils/bignumber/bitAnd.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/utils/bignumber/bitOr.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/utils/bignumber/bitXor.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/utils/bignumber/isBigNumber.js","webpack:////home/badou/Desktop/LastProject/trouvkach/node_modules/mathjs/lib/utils/bignumber/bitwise.js"],"names":["module","exports","x","isFinite","isInteger","Error","BigNumber","constructor","prevPrec","precision","config","result","plus","s","memoize","__webpack_require__","hasher","args","e","exp","phi","sqrt","div","pi","acos","tau","times","objectUtils","format","value","options","isNaN","gt","notation","undefined","toFixed","toExponential","exponential","lower","upper","fixedOptions","map","lowerExp","Math","round","log","LN10","upperExp","console","warn","JSON","stringify","isZero","toSignificantDigits","replace","digits","arguments","bitwise","y","NaN","eq","isNegative","a","b","negOne","bitNot","Infinity","prototype","isBigNumber","decCoefficientToBinaryString","d","r","i","length","z","j","charAt","xe","str","slice","strL","arr","_i2","arrL","parseInt","_j","reverse","func","xBits","yBits","minBits","maxBits","minSign","xSign","ySign","_i","shortLen","longLen","expFuncVal","outVal","twoPower","two"],"mappings":"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","file":"js/a53e2941cfc52318cec8.js","sourcesContent":["'use strict';\n/**\n * Bitwise not\n * @param {BigNumber} x\n * @return {BigNumber} Result of ~`x`, fully precise\n *\n */\n\nmodule.exports = function bitNot(x) {\n  if (x.isFinite() && !x.isInteger()) {\n    throw new Error('Integer expected in function bitNot');\n  }\n\n  var BigNumber = x.constructor;\n  var prevPrec = BigNumber.precision;\n  BigNumber.config({\n    precision: 1E9\n  });\n  var result = x.plus(new BigNumber(1));\n  result.s = -result.s || null;\n  BigNumber.config({\n    precision: prevPrec\n  });\n  return result;\n};","'use strict';\n\nvar memoize = require('../function').memoize;\n/**\n * Calculate BigNumber e\n * @param {function} BigNumber   BigNumber constructor\n * @returns {BigNumber} Returns e\n */\n\n\nexports.e = memoize(function (BigNumber) {\n  return new BigNumber(1).exp();\n}, hasher);\n/**\n * Calculate BigNumber golden ratio, phi = (1+sqrt(5))/2\n * @param {function} BigNumber   BigNumber constructor\n * @returns {BigNumber} Returns phi\n */\n\nexports.phi = memoize(function (BigNumber) {\n  return new BigNumber(1).plus(new BigNumber(5).sqrt()).div(2);\n}, hasher);\n/**\n * Calculate BigNumber pi.\n * @param {function} BigNumber   BigNumber constructor\n * @returns {BigNumber} Returns pi\n */\n\nexports.pi = memoize(function (BigNumber) {\n  return BigNumber.acos(-1);\n}, hasher);\n/**\n * Calculate BigNumber tau, tau = 2 * pi\n * @param {function} BigNumber   BigNumber constructor\n * @returns {BigNumber} Returns tau\n */\n\nexports.tau = memoize(function (BigNumber) {\n  return exports.pi(BigNumber).times(2);\n}, hasher);\n/**\n * Create a hash for a BigNumber constructor function. The created has is\n * the configured precision\n * @param {Array} args         Supposed to contain a single entry with\n *                             a BigNumber constructor\n * @return {number} precision\n * @private\n */\n\nfunction hasher(args) {\n  return args[0].precision;\n}","'use strict';\n\nvar objectUtils = require('../object');\n/**\n * Convert a BigNumber to a formatted string representation.\n *\n * Syntax:\n *\n *    format(value)\n *    format(value, options)\n *    format(value, precision)\n *    format(value, fn)\n *\n * Where:\n *\n *    {number} value   The value to be formatted\n *    {Object} options An object with formatting options. Available options:\n *                     {string} notation\n *                         Number notation. Choose from:\n *                         'fixed'          Always use regular number notation.\n *                                          For example '123.40' and '14000000'\n *                         'exponential'    Always use exponential notation.\n *                                          For example '1.234e+2' and '1.4e+7'\n *                         'auto' (default) Regular number notation for numbers\n *                                          having an absolute value between\n *                                          `lower` and `upper` bounds, and uses\n *                                          exponential notation elsewhere.\n *                                          Lower bound is included, upper bound\n *                                          is excluded.\n *                                          For example '123.4' and '1.4e7'.\n *                     {number} precision   A number between 0 and 16 to round\n *                                          the digits of the number.\n *                                          In case of notations 'exponential',\n *                                          'engineering', and 'auto',\n *                                          `precision` defines the total\n *                                          number of significant digits returned.\n *                                          In case of notation 'fixed',\n *                                          `precision` defines the number of\n *                                          significant digits after the decimal\n *                                          point.\n *                                          `precision` is undefined by default.\n *                     {number} lowerExp    Exponent determining the lower boundary\n *                                          for formatting a value with an exponent\n *                                          when `notation='auto`.\n *                                          Default value is `-3`.\n *                     {number} upperExp    Exponent determining the upper boundary\n *                                          for formatting a value with an exponent\n *                                          when `notation='auto`.\n *                                          Default value is `5`.\n *    {Function} fn    A custom formatting function. Can be used to override the\n *                     built-in notations. Function `fn` is called with `value` as\n *                     parameter and must return a string. Is useful for example to\n *                     format all values inside a matrix in a particular way.\n *\n * Examples:\n *\n *    format(6.4)                                        // '6.4'\n *    format(1240000)                                    // '1.24e6'\n *    format(1/3)                                        // '0.3333333333333333'\n *    format(1/3, 3)                                     // '0.333'\n *    format(21385, 2)                                   // '21000'\n *    format(12e8, {notation: 'fixed'})                  // returns '1200000000'\n *    format(2.3,    {notation: 'fixed', precision: 4})  // returns '2.3000'\n *    format(52.8,   {notation: 'exponential'})          // returns '5.28e+1'\n *    format(12400,  {notation: 'engineering'})          // returns '12.400e+3'\n *\n * @param {BigNumber} value\n * @param {Object | Function | number} [options]\n * @return {string} str The formatted value\n */\n\n\nexports.format = function (value, options) {\n  if (typeof options === 'function') {\n    // handle format(value, fn)\n    return options(value);\n  } // handle special cases\n\n\n  if (!value.isFinite()) {\n    return value.isNaN() ? 'NaN' : value.gt(0) ? 'Infinity' : '-Infinity';\n  } // default values for options\n\n\n  var notation = 'auto';\n  var precision;\n\n  if (options !== undefined) {\n    // determine notation from options\n    if (options.notation) {\n      notation = options.notation;\n    } // determine precision from options\n\n\n    if (typeof options === 'number') {\n      precision = options;\n    } else if (options.precision) {\n      precision = options.precision;\n    }\n  } // handle the various notations\n\n\n  switch (notation) {\n    case 'fixed':\n      return exports.toFixed(value, precision);\n\n    case 'exponential':\n      return exports.toExponential(value, precision);\n\n    case 'auto':\n      // TODO: clean up some day. Deprecated since: 2018-01-24\n      // @deprecated upper and lower are replaced with upperExp and lowerExp since v4.0.0\n      if (options && options.exponential && (options.exponential.lower !== undefined || options.exponential.upper !== undefined)) {\n        var fixedOptions = objectUtils.map(options, function (x) {\n          return x;\n        });\n        fixedOptions.exponential = undefined;\n\n        if (options.exponential.lower !== undefined) {\n          fixedOptions.lowerExp = Math.round(Math.log(options.exponential.lower) / Math.LN10);\n        }\n\n        if (options.exponential.upper !== undefined) {\n          fixedOptions.upperExp = Math.round(Math.log(options.exponential.upper) / Math.LN10);\n        }\n\n        console.warn('Deprecation warning: Formatting options exponential.lower and exponential.upper ' + '(minimum and maximum value) ' + 'are replaced with exponential.lowerExp and exponential.upperExp ' + '(minimum and maximum exponent) since version 4.0.0. ' + 'Replace ' + JSON.stringify(options) + ' with ' + JSON.stringify(fixedOptions));\n        return exports.format(value, fixedOptions);\n      } // determine lower and upper bound for exponential notation.\n      // TODO: implement support for upper and lower to be BigNumbers themselves\n\n\n      var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;\n      var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5; // handle special case zero\n\n      if (value.isZero()) return '0'; // determine whether or not to output exponential notation\n\n      var str;\n      var exp = value.e;\n\n      if (exp >= lowerExp && exp < upperExp) {\n        // normal number notation\n        str = value.toSignificantDigits(precision).toFixed();\n      } else {\n        // exponential notation\n        str = exports.toExponential(value, precision);\n      } // remove trailing zeros after the decimal point\n\n\n      return str.replace(/((\\.\\d*?)(0+))($|e)/, function () {\n        var digits = arguments[2];\n        var e = arguments[4];\n        return digits !== '.' ? digits + e : e;\n      });\n\n    default:\n      throw new Error('Unknown notation \"' + notation + '\". ' + 'Choose \"auto\", \"exponential\", or \"fixed\".');\n  }\n};\n/**\n * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'\n * @param {BigNumber} value\n * @param {number} [precision]  Number of digits in formatted output.\n *                              If not provided, the maximum available digits\n *                              is used.\n * @returns {string} str\n */\n\n\nexports.toExponential = function (value, precision) {\n  if (precision !== undefined) {\n    return value.toExponential(precision - 1); // Note the offset of one\n  } else {\n    return value.toExponential();\n  }\n};\n/**\n * Format a number with fixed notation.\n * @param {BigNumber} value\n * @param {number} [precision=undefined] Optional number of decimals after the\n *                                       decimal point. Undefined by default.\n */\n\n\nexports.toFixed = function (value, precision) {\n  return value.toFixed(precision);\n};","'use strict';\n\nvar bitwise = require('./bitwise');\n/**\n * Bitwise and for Bignumbers\n *\n * Special Cases:\n *   N &  n =  N\n *   n &  0 =  0\n *   n & -1 =  n\n *   n &  n =  n\n *   I &  I =  I\n *  -I & -I = -I\n *   I & -I =  0\n *   I &  n =  n\n *   I & -n =  I\n *  -I &  n =  0\n *  -I & -n = -I\n *\n * @param {BigNumber} x\n * @param {BigNumber} y\n * @return {BigNumber} Result of `x` & `y`, is fully precise\n * @private\n */\n\n\nmodule.exports = function bitAnd(x, y) {\n  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {\n    throw new Error('Integers expected in function bitAnd');\n  }\n\n  var BigNumber = x.constructor;\n\n  if (x.isNaN() || y.isNaN()) {\n    return new BigNumber(NaN);\n  }\n\n  if (x.isZero() || y.eq(-1) || x.eq(y)) {\n    return x;\n  }\n\n  if (y.isZero() || x.eq(-1)) {\n    return y;\n  }\n\n  if (!x.isFinite() || !y.isFinite()) {\n    if (!x.isFinite() && !y.isFinite()) {\n      if (x.isNegative() === y.isNegative()) {\n        return x;\n      }\n\n      return new BigNumber(0);\n    }\n\n    if (!x.isFinite()) {\n      if (y.isNegative()) {\n        return x;\n      }\n\n      if (x.isNegative()) {\n        return new BigNumber(0);\n      }\n\n      return y;\n    }\n\n    if (!y.isFinite()) {\n      if (x.isNegative()) {\n        return y;\n      }\n\n      if (y.isNegative()) {\n        return new BigNumber(0);\n      }\n\n      return x;\n    }\n  }\n\n  return bitwise(x, y, function (a, b) {\n    return a & b;\n  });\n};","'use strict';\n\nvar bitwise = require('./bitwise');\n/**\n * Bitwise OR for BigNumbers\n *\n * Special Cases:\n *   N |  n =  N\n *   n |  0 =  n\n *   n | -1 = -1\n *   n |  n =  n\n *   I |  I =  I\n *  -I | -I = -I\n *   I | -n = -1\n *   I | -I = -1\n *   I |  n =  I\n *  -I |  n = -I\n *  -I | -n = -n\n *\n * @param {BigNumber} x\n * @param {BigNumber} y\n * @return {BigNumber} Result of `x` | `y`, fully precise\n */\n\n\nmodule.exports = function bitOr(x, y) {\n  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {\n    throw new Error('Integers expected in function bitOr');\n  }\n\n  var BigNumber = x.constructor;\n\n  if (x.isNaN() || y.isNaN()) {\n    return new BigNumber(NaN);\n  }\n\n  var negOne = new BigNumber(-1);\n\n  if (x.isZero() || y.eq(negOne) || x.eq(y)) {\n    return y;\n  }\n\n  if (y.isZero() || x.eq(negOne)) {\n    return x;\n  }\n\n  if (!x.isFinite() || !y.isFinite()) {\n    if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {\n      return negOne;\n    }\n\n    if (x.isNegative() && y.isNegative()) {\n      return x.isFinite() ? x : y;\n    }\n\n    return x.isFinite() ? y : x;\n  }\n\n  return bitwise(x, y, function (a, b) {\n    return a | b;\n  });\n};","'use strict';\n\nvar bitwise = require('./bitwise');\n\nvar bitNot = require('./bitNot');\n/**\n * Bitwise XOR for BigNumbers\n *\n * Special Cases:\n *   N ^  n =  N\n *   n ^  0 =  n\n *   n ^  n =  0\n *   n ^ -1 = ~n\n *   I ^  n =  I\n *   I ^ -n = -I\n *   I ^ -I = -1\n *  -I ^  n = -I\n *  -I ^ -n =  I\n *\n * @param {BigNumber} x\n * @param {BigNumber} y\n * @return {BigNumber} Result of `x` ^ `y`, fully precise\n *\n */\n\n\nmodule.exports = function bitXor(x, y) {\n  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {\n    throw new Error('Integers expected in function bitXor');\n  }\n\n  var BigNumber = x.constructor;\n\n  if (x.isNaN() || y.isNaN()) {\n    return new BigNumber(NaN);\n  }\n\n  if (x.isZero()) {\n    return y;\n  }\n\n  if (y.isZero()) {\n    return x;\n  }\n\n  if (x.eq(y)) {\n    return new BigNumber(0);\n  }\n\n  var negOne = new BigNumber(-1);\n\n  if (x.eq(negOne)) {\n    return bitNot(y);\n  }\n\n  if (y.eq(negOne)) {\n    return bitNot(x);\n  }\n\n  if (!x.isFinite() || !y.isFinite()) {\n    if (!x.isFinite() && !y.isFinite()) {\n      return negOne;\n    }\n\n    return new BigNumber(x.isNegative() === y.isNegative() ? Infinity : -Infinity);\n  }\n\n  return bitwise(x, y, function (a, b) {\n    return a ^ b;\n  });\n};","'use strict';\n/**\n * Test whether a value is a BigNumber\n * @param {*} x\n * @return {boolean}\n */\n\nmodule.exports = function isBigNumber(x) {\n  return x && x.constructor.prototype.isBigNumber || false;\n};","'use strict';\n\nvar bitNot = require('./bitNot');\n/**\n * Applies bitwise function to numbers\n * @param {BigNumber} x\n * @param {BigNumber} y\n * @param {function (a, b)} func\n * @return {BigNumber}\n */\n\n\nmodule.exports = function bitwise(x, y, func) {\n  var BigNumber = x.constructor;\n  var xBits, yBits;\n  var xSign = +(x.s < 0);\n  var ySign = +(y.s < 0);\n\n  if (xSign) {\n    xBits = decCoefficientToBinaryString(bitNot(x));\n\n    for (var i = 0; i < xBits.length; ++i) {\n      xBits[i] ^= 1;\n    }\n  } else {\n    xBits = decCoefficientToBinaryString(x);\n  }\n\n  if (ySign) {\n    yBits = decCoefficientToBinaryString(bitNot(y));\n\n    for (var _i = 0; _i < yBits.length; ++_i) {\n      yBits[_i] ^= 1;\n    }\n  } else {\n    yBits = decCoefficientToBinaryString(y);\n  }\n\n  var minBits, maxBits, minSign;\n\n  if (xBits.length <= yBits.length) {\n    minBits = xBits;\n    maxBits = yBits;\n    minSign = xSign;\n  } else {\n    minBits = yBits;\n    maxBits = xBits;\n    minSign = ySign;\n  }\n\n  var shortLen = minBits.length;\n  var longLen = maxBits.length;\n  var expFuncVal = func(xSign, ySign) ^ 1;\n  var outVal = new BigNumber(expFuncVal ^ 1);\n  var twoPower = new BigNumber(1);\n  var two = new BigNumber(2);\n  var prevPrec = BigNumber.precision;\n  BigNumber.config({\n    precision: 1E9\n  });\n\n  while (shortLen > 0) {\n    if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {\n      outVal = outVal.plus(twoPower);\n    }\n\n    twoPower = twoPower.times(two);\n  }\n\n  while (longLen > 0) {\n    if (func(minSign, maxBits[--longLen]) === expFuncVal) {\n      outVal = outVal.plus(twoPower);\n    }\n\n    twoPower = twoPower.times(two);\n  }\n\n  BigNumber.config({\n    precision: prevPrec\n  });\n\n  if (expFuncVal === 0) {\n    outVal.s = -outVal.s;\n  }\n\n  return outVal;\n};\n/* Extracted from decimal.js, and edited to specialize. */\n\n\nfunction decCoefficientToBinaryString(x) {\n  // Convert to string\n  var a = x.d; // array with digits\n\n  var r = a[0] + '';\n\n  for (var i = 1; i < a.length; ++i) {\n    var s = a[i] + '';\n\n    for (var z = 7 - s.length; z--;) {\n      s = '0' + s;\n    }\n\n    r += s;\n  }\n\n  var j = r.length;\n\n  while (r.charAt(j) === '0') {\n    j--;\n  }\n\n  var xe = x.e;\n  var str = r.slice(0, j + 1 || 1);\n  var strL = str.length;\n\n  if (xe > 0) {\n    if (++xe > strL) {\n      // Append zeros.\n      xe -= strL;\n\n      while (xe--) {\n        str += '0';\n      }\n    } else if (xe < strL) {\n      str = str.slice(0, xe) + '.' + str.slice(xe);\n    }\n  } // Convert from base 10 (decimal) to base 2\n\n\n  var arr = [0];\n\n  for (var _i2 = 0; _i2 < str.length;) {\n    var arrL = arr.length;\n\n    while (arrL--) {\n      arr[arrL] *= 10;\n    }\n\n    arr[0] += parseInt(str.charAt(_i2++)); // convert to int\n\n    for (var _j = 0; _j < arr.length; ++_j) {\n      if (arr[_j] > 1) {\n        if (arr[_j + 1] === null || arr[_j + 1] === undefined) {\n          arr[_j + 1] = 0;\n        }\n\n        arr[_j + 1] += arr[_j] >> 1;\n        arr[_j] &= 1;\n      }\n    }\n  }\n\n  return arr.reverse();\n}"],"sourceRoot":""}